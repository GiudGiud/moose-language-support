// Generated by CoffeeScript 2.7.0
(function() {
  // coffeelint: disable=max_line_length
  var Parser, appDirs, cp, fs, insideBlockTag, mooseApp, otherParameter, parameterCompletion, parser, path, readline, stdVector, suggestionIcon, syntaxWarehouse, tree, typeParameter;

  fs = require('fs-plus');

  cp = require('child_process');

  path = require('path');

  readline = require('readline');

  Parser = require('web-tree-sitter');

  parser = void 0;

  tree = void 0;

  // while the Parser is initializing and loading the language, we block its use
  Parser.init().then(function() {
    return Parser.Language.load(path.join(__dirname, './tree-sitter-hit.wasm')).then(function(lang) {
      parser = new Parser();
      return parser.setLanguage(lang);
    });
  });

  insideBlockTag = /^\s*\[([^\]#\s]*)$/;

  parameterCompletion = /^\s*[^\s#=\]]*$/;

  typeParameter = /^\s*type\s*=\s*[^\s#=\]]*$/;

  otherParameter = /^\s*([^\s#=\]]+)\s*=\s*('\s*[^\s'#=\]]*(\s?)[^'#=\]]*|[^\s#=\]]*)$/;

  mooseApp = /^(.*)-(opt|dbg|oprof|devel)$/;

  stdVector = /^std::([^:]+::)?vector<([a-zA-Z0-9_]+)(,\s?std::\1allocator<\2>\s?)?>$/;

  suggestionIcon = {
    required: '<i class="icon-primitive-square text-error"></i>',
    hasDefault: '<i class="icon-primitive-square text-success"></i>',
    noDefault: '<i class="icon-primitive-dot text-success"></i>',
    type: '<i class="icon-gear keyword"></i>',
    output: '<i class="icon-database text-info"></i>'
  };

  // each moose input file in the project dir could have its own moose app and
  // json/syntax associated this table points to the app dir for each editor path
  appDirs = {};

  syntaxWarehouse = {};

  module.exports = {
    selector: '.input.moose',
    disableForSelector: '.input.moose .comment',
    inclusionPriority: 1,
    excludeLowerPriority: true,
    // This will be suggested before the default provider, which has a suggestionPriority of 1.
    suggestionPriority: 2,
    // Tell autocomplete to fuzzy filter the results of getSuggestions(). We are
    // still filtering by the first character of the prefix in this provider for
    // efficiency.
    filterSuggestions: true,
    // include parameters marked as deprecated in the suggestions
    hideDeprecatedParams: null,
    // offline syntax dump
    offlineSyntax: null,
    // Clear the cache for the app associated with current file.
    // This is made available as an atom command.
    clearCache: function() {
      var appPath, editor, filePath;
      editor = atom.workspace.getActiveTextEditor();
      filePath = path.dirname(editor.getPath());
      if (filePath in appDirs) {
        appPath = appDirs[filePath].appPath;
        delete appDirs[filePath];
        if (appPath in syntaxWarehouse) {
          return delete syntaxWarehouse[appPath];
        }
      }
    },
    // entry point for the suggestion provider
    // this function will load the syntax files if neccessary before callling
    // the actual completion suggestion builder
    getSuggestions: function(request) {
      var dir, filePath, loaded, w;
      filePath = path.dirname(request.editor.getPath());
      // lookup application for current input file (cached)
      if (this.offlineSyntax) {
        dir = {
          appPath: this.offlineSyntax,
          appName: null,
          appFile: null,
          appDate: null,
          appWSL: null
        };
      } else {
        dir = this.findApp(filePath);
      }
      if (dir == null) {
        return [];
      }
      // check if the syntax is already loaded, currently loading,
      // or not requested yet
      if (dir.appPath in syntaxWarehouse) {
        w = syntaxWarehouse[dir.appPath];
        // still loading
        if ('promise' in w) {
          return w.promise.then(() => {
            return this.prepareCompletion(request, w);
          });
        } else {
          // syntax is loaded
          return this.prepareCompletion(request, w);
        }
      } else {
        // return a promise that gets fulfilled as soon as the syntax data is loaded
        loaded = this.loadSyntax(dir);
        return loaded.then(() => {
          // watch executable (unless it's WSL)
          if ((dir.appFile != null) && (dir.appWSL == null)) {
            fs.watch(dir.appFile, function(event, filename) {
              // force rebuilding of syntax if executable changed
              delete appDirs[filePath];
              return delete syntaxWarehouse[dir.appPath];
            });
          }
          // perform completion
          return this.prepareCompletion(request, syntaxWarehouse[dir.appPath]);
        });
      }
    },
    prepareCompletion: function(request, w) {
      // tree update
      if (parser == null) {
        return;
      }
      tree = parser.parse(request.editor.getBuffer().getText());
      return this.computeCompletion(request, w);
    },
    // get the node in the JSON stucture for the current block level
    getSyntaxNode: function(configPath, w) {
      var b, i, len, p, ref, ref1;
      // no parameters at the root
      if (configPath.length === 0) {
        return void 0;
      }
      // traverse subblocks
      b = w.json.blocks[configPath[0]];
      ref = configPath.slice(1);
      for (i = 0, len = ref.length; i < len; i++) {
        p = ref[i];
        b = (b != null ? (ref1 = b.subblocks) != null ? ref1[p] : void 0 : void 0) || (b != null ? b.star : void 0);
        if (b == null) {
          return void 0;
        }
      }
      return b;
    },
    // get a list of valid subblocks
    getSubblocks: function(configPath, w) {
      var b, ret;
      // get top level blocks
      if (configPath.length === 0) {
        return Object.keys(w.json.blocks);
      }
      // traverse subblocks
      b = this.getSyntaxNode(configPath, w);
      ret = Object.keys((b != null ? b.subblocks : void 0) || {});
      if (b != null ? b.star : void 0) {
        ret.push('*');
      }
      return ret.sort();
    },
    // get a list of parameters for the current block
    // if the type parameter is known add in class specific parameters
    getParameters: function(configPath, explicitType, w) {
      var b, currentType, n, ref, ref1, ref2, ret, t;
      ret = {};
      b = this.getSyntaxNode(configPath, w);
// handle block level action parameters first
      for (n in b != null ? b.actions : void 0) {
        Object.assign(ret, b.actions[n].parameters);
      }
      // if no type is explicitly set check if a default value exists
      currentType = explicitType || (ret != null ? (ref = ret.type) != null ? ref.default : void 0 : void 0);
      // if the type is known add the specific parameters
      t = (b != null ? (ref1 = b.subblock_types) != null ? ref1[currentType] : void 0 : void 0) || (b != null ? (ref2 = b.types) != null ? ref2[currentType] : void 0 : void 0);
      Object.assign(ret, t != null ? t.parameters : void 0);
      return ret;
    },
    // get a list of possible completions for the type parameter at the current block level
    getTypes: function(configPath, w) {
      var b, n, ret;
      ret = [];
      b = this.getSyntaxNode(configPath, w);
      for (n in b != null ? b.subblock_types : void 0) {
        ret.push({
          text: n,
          description: b.subblock_types[n].description
        });
      }
      for (n in b != null ? b.types : void 0) {
        ret.push({
          text: n,
          description: b.types[n].description
        });
      }
      return ret;
    },
    // Filename completions
    computeFileNameCompletion: function(wildcards, editor) {
      var completions, dir, filePath, i, len, name;
      filePath = path.dirname(editor.getPath());
      dir = fs.readdirSync(filePath);
      completions = [];
      for (i = 0, len = dir.length; i < len; i++) {
        name = dir[i];
        completions.push({
          text: name
        });
      }
      return completions;
    },
    // checks if this is a vector type build the vector cpp_type name for a
    // given single type (checks for gcc and clang variants)
    isVectorOf: function(yamlType, type) {
      var match;
      return (match = stdVector.exec(yamlType)) && match[2] === type;
    },
    // build the suggestion list for parameter values (editor is passed in
    // to build the variable list)
    computeValueCompletion: function(param, editor, isQuoted, hasSpace, w) {
      var basicType, blockList, buildBlockList, completions, hasType, i, len, match, matches, option, output, ref, singleOK, vectorOK;
      singleOK = !hasSpace;
      vectorOK = isQuoted || !hasSpace;
      hasType = (type) => {
        return (param.cpp_type === type && singleOK) || (this.isVectorOf(param.cpp_type, type) && vectorOK);
      };
      blockList = [];
      buildBlockList = function(node, oldPath) {
        var block, c, i, len, newPath, ref, results;
        ref = node.children;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (c.type === 'top_block' || c.type === 'block') {
            block = c.children[1].text;
            if (block.slice(0, 2) === './') {
              block = block.slice(2);
            }
            newPath = (oldPath ? oldPath + '/' : '') + block;
            blockList.push(newPath);
            results.push(buildBlockList(c, newPath));
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      if ((param.cpp_type === 'bool' && singleOK) || (this.isVectorOf(param.cpp_type, 'bool') && vectorOK)) {
        return [
          {
            text: 'true'
          },
          {
            text: 'false'
          }
        ];
      }
      if ((param.cpp_type === 'MooseEnum' && singleOK) || (param.cpp_type === 'MultiMooseEnum' && vectorOK)) {
        if (param.options != null) {
          completions = [];
          ref = param.options.split(' ');
          for (i = 0, len = ref.length; i < len; i++) {
            option = ref[i];
            completions.push({
              text: option
            });
          }
          return completions;
        }
      }
      match = param.cpp_type.match(/^std::vector<([^>]+)>$/);
      if ((match && !vectorOK) || (!match && !singleOK)) {
        return [];
      }
      basicType = match ? match[1] : param.cpp_type;
      if (basicType === 'FileName') {
        return this.computeFileNameCompletion(['*'], editor);
      }
      if (basicType === 'MeshFileName') {
        return this.computeFileNameCompletion(['*.e'], editor);
      }
      if (basicType === 'OutputName') {
        return (function() {
          var j, len1, ref1, results;
          ref1 = ['exodus', 'csv', 'console', 'gmv', 'gnuplot', 'nemesis', 'tecplot', 'vtk', 'xda', 'xdr'];
          results = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            output = ref1[j];
            results.push({
              text: output,
              iconHTML: suggestionIcon.output
            });
          }
          return results;
        })();
      }
      // automatically generated matches from registerSyntaxType
      if (basicType in w.json.global.associated_types) {
        buildBlockList(tree.rootNode);
        completions = [];
        matches = new Set(w.json.global.associated_types[basicType]);
        matches.forEach(function(match) {
          var block, j, key, len1, results;
          if (match.slice(-2) === '/*') {
            key = match.slice(0, -1);
            results = [];
            for (j = 0, len1 = blockList.length; j < len1; j++) {
              block = blockList[j];
              if (block.slice(0, +(key.length - 1) + 1 || 9e9) === key) {
                results.push(completions.push({
                  text: block.slice(key.length)
                }));
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        });
        return completions;
      }
      return [];
    },
    getPrefix: function(line) {
      var ref, regex;
      // Whatever your prefix regex might be
      regex = /[\w0-9_\-.\/\[]+$/;
      // Match the regex to the line, and return the match
      return ((ref = line.match(regex)) != null ? ref[0] : void 0) || '';
    },
    // w contains the syntax applicable to the current file
    computeCompletion: function(request, w) {
      var addedWildcard, blockPostfix, blockPrefix, bufferPosition, completion, completions, configPath, defaultValue, editor, explicitType, hasSpace, i, icon, isQuoted, j, len, len1, line, match, name, param, paramName, partialPath, postLine, prefix, ref, ref1;
      ({editor, bufferPosition} = request);
      completions = [];
      // current line up to the cursor position
      line = editor.getTextInRange([[bufferPosition.row, 0], bufferPosition]);
      prefix = this.getPrefix(line);
      // get the type pseudo path (for the yaml)
      ({configPath, explicitType} = this.getCurrentConfigPath(editor, bufferPosition));
      // for empty [] we suggest blocks
      if (this.isOpenBracketPair(line)) {
        // get a partial path
        partialPath = line.match(insideBlockTag)[1].replace(/^\.\//, '').split('/');
        partialPath.pop();
        // get the postfix (to determine if we need to append a ] or not)
        postLine = editor.getTextInRange([bufferPosition, [bufferPosition.row, bufferPosition.column + 1]]);
        blockPostfix = postLine.length > 0 && postLine[0] === ']' ? '' : ']';
        // handle relative paths
        blockPrefix = configPath.length > 0 ? '[./' : '[';
        // add block close tag to suggestions
        if (configPath.length > 0 && partialPath.length === 0) {
          completions.push({
            text: '[../' + blockPostfix,
            displayText: '..'
          });
        }
        configPath = configPath.concat(partialPath);
        ref = this.getSubblocks(configPath, w);
        for (i = 0, len = ref.length; i < len; i++) {
          completion = ref[i];
          // add to suggestions if it is a new suggestion
          if (completion === '*') {
            if (!addedWildcard) {
              completions.push({
                displayText: '*',
                snippet: blockPrefix + '${1:name}' + blockPostfix
              });
              addedWildcard = true;
            }
          } else if (completion !== '') {
            if ((completions.findIndex(function(c) {
              return c.displayText === completion;
            })) < 0) {
              completions.push({
                text: blockPrefix + [...partialPath, completion].join('/') + blockPostfix,
                displayText: completion
              });
            }
          }
        }
      // suggest parameters
      } else if (this.isParameterCompletion(line)) {
        ref1 = this.getParameters(configPath, explicitType, w);
        // loop over valid parameters
        for (name in ref1) {
          param = ref1[name];
          // skip deprecated params
          if (this.hideDeprecatedParams && param.deprecated) {
            continue;
          }
          defaultValue = param.default || '';
          if (defaultValue.indexOf(' ') >= 0) {
            defaultValue = `'${defaultValue}'`;
          }
          if (param.cpp_type === 'bool') {
            if (defaultValue === '0') {
              defaultValue = 'false';
            }
            if (defaultValue === '1') {
              defaultValue = 'true';
            }
          }
          icon = param.name === 'type' ? suggestionIcon['type'] : param.required ? suggestionIcon['required'] : param.default != null ? suggestionIcon['hasDefault'] : suggestionIcon['noDefault'];
          completions.push({
            displayText: param.name,
            snippet: param.name + ' = ${1:' + defaultValue + '}',
            description: param.description,
            iconHTML: icon
          });
        }
      } else if (!!(match = otherParameter.exec(line))) {
        paramName = match[1];
        isQuoted = match[2][0] === "'";
        hasSpace = !!match[3];
        param = (this.getParameters(configPath, explicitType, w))[paramName];
        if (param == null) {
          return [];
        }
        // this takes care of 'broken' type parameters like Executioner/Qudadrature/type
        if (paramName === 'type' && param.cpp_type === 'std::string') {
          completions = this.getTypes(configPath, w);
        } else {
          completions = this.computeValueCompletion(param, editor, isQuoted, hasSpace, w);
        }
      }
// set the custom prefix
      for (j = 0, len1 = completions.length; j < len1; j++) {
        completion = completions[j];
        completion.replacementPrefix = prefix;
      }
      return completions;
    },
    onDidInsertSuggestion: function({editor, suggestion}) {
      if (suggestion.type === 'property') {
        return setTimeout(this.triggerAutocomplete.bind(this, editor), 1);
      }
    },
    triggerAutocomplete: function(editor) {
      return atom.commands.dispatch(atom.views.getView(editor), 'autocomplete-plus:activate', {
        activatedManually: false
      });
    },
    // check if there is an square bracket pair around the cursor
    isOpenBracketPair: function(line) {
      return insideBlockTag.test(line);
    },
    // check if the current line is a type parameter
    isParameterCompletion: function(line) {
      return parameterCompletion.test(line);
    },
    // determine the active input file path at the current position
    getCurrentConfigPath: function(editor, position) {
      var c, i, len, node, recurseCurrentConfigPath, ref, ret, sourcePath;
      recurseCurrentConfigPath = function(node, sourcePath = []) {
        var c, c2, ce, cs, i, j, len, len1, ref, ref1;
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (c.type !== 'top_block' && c.type !== 'block' && c.type !== 'ERROR') {
            continue;
          }
          // check if we are inside a block or top_block
          cs = c.startPosition;
          ce = c.endPosition;
          // outside row range
          if (position.row < cs.row || position.row > ce.row) {
            continue;
          }
          // in starting row but before starting column
          if (position.row === cs.row && position.column < cs.column) {
            continue;
          }
          // in ending row but after ending column
          if (position.row === ce.row && position.column > ce.column) {
            continue;
          }
          // if the block does not contain a valid path subnode we give up
          if (c.children.length < 2 || c.children[1].type !== 'block_path') {
            return [c.parent, sourcePath];
          }
          // first block_path node
          if (c.type !== 'ERROR') {
            if (c.children[1].startPosition.row >= position.row) {
              continue;
            }
            sourcePath = sourcePath.concat(c.children[1].text.replace(/^\.\//, '').split('/'));
          } else {
            ref1 = c.children;
            // if we are in an ERROR block (unclosed) we should try to pick more path elements
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              c2 = ref1[j];
              if (c2.type !== 'block_path' || c2.startPosition.row >= position.row) {
                continue;
              }
              sourcePath = sourcePath.concat(c2.text.replace(/^\.\//, '').split('/'));
            }
          }
          return recurseCurrentConfigPath(c, sourcePath);
        }
        return [node, sourcePath];
      };
      [node, sourcePath] = recurseCurrentConfigPath(tree.rootNode);
      ret = {
        configPath: sourcePath,
        explicitType: null
      };
      // found a block we can check for a type parameter
      if (node !== null) {
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (c.type !== 'parameter_definition' || c.children.length < 3 || c.children[0].text !== 'type') {
            continue;
          }
          ret.explicitType = c.children[2].text;
          break;
        }
      }
      // return value
      return ret;
    },
    findApp: function(filePath) {
      var fallbackMooseDir, file, fileTime, fileWithPath, i, isWSL, len, match, matches, previous_path, ref, searchPath, stats, wslDistro, wslPath;
      if (filePath == null) {
        atom.notifications.addError('File not saved, nowhere to search for MOOSE syntax data.', {
          dismissable: true
        });
        return null;
      }
      if (filePath in appDirs) {
        return appDirs[filePath];
      }
      // is this a WSL (Windows Subsystem for Linux) path?
      isWSL = filePath.slice(0, 7).toLowerCase() === '\\\\wsl$\\';
      searchPath = filePath;
      matches = [];
      while (true) {
        ref = fs.readdirSync(searchPath);
        // list all files
        for (i = 0, len = ref.length; i < len; i++) {
          file = ref[i];
          match = mooseApp.exec(file);
          if (match) {
            fileWithPath = path.join(searchPath, file);
            if (!isWSL && !fs.isExecutableSync(fileWithPath)) {
              // on non-WSL systems we make sure the matched path is executable
              continue;
            }
            stats = fs.statSync(fileWithPath);
            if (!isWSL && stats.isDirectory()) {
              // ignore directories that match the naming pattern
              continue;
            }
            fileTime = stats.mtime.getTime();
            // convert from Windows to WSL Unix path
            if (isWSL) {
              wslPath = fileWithPath.slice(7).split('\\');
              fileWithPath = '/' + wslPath.slice(1).join('/');
              wslDistro = wslPath[0];
            } else {
              wslDistro = null;
            }
            matches.push({
              appPath: searchPath,
              appName: match[1],
              appFile: fileWithPath,
              appDate: fileTime,
              appWSL: wslDistro
            });
          }
        }
        if (matches.length > 0) {
          // return newest application
          matches.sort(function(a, b) {
            return b.appDate - a.appDate;
          });
          appDirs[filePath] = matches[0];
          return appDirs[filePath];
        }
        // go to parent
        previous_path = searchPath;
        searchPath = path.join(searchPath, '..');
        if (searchPath === previous_path) {
          // no executable found, let's check the fallback path
          fallbackMooseDir = atom.config.get("autocomplete-moose.fallbackMooseDir");
          if (fallbackMooseDir !== '' && filePath !== fallbackMooseDir) {
            return this.findApp(fallbackMooseDir);
          }
          if (!atom.config.get("autocomplete-moose.ignoreMooseNotFoundError")) {
            // otherwise pop up an error notification (if not disabled) end give up
            atom.notifications.addError('No MOOSE application executable found.', {
              dismissable: true
            });
          }
          return null;
        }
      }
    },
    // rebuild syntax
    rebuildSyntax: function(app, cacheFile, w) {
      var appDate, appFile, appName, appPath, appWSL, mooseJSON, workingNotification;
      ({appPath, appName, appFile, appDate, appWSL} = app);
      // open notification about syntax generation
      workingNotification = atom.notifications.addInfo('Rebuilding MOOSE syntax data.', {
        dismissable: true
      });
      // rebuild the syntax by running moose with --json
      mooseJSON = new Promise((resolve, reject) => {
        var args, jsonData, moose;
        jsonData = '';
        // either run moose or use the offlineSyntax file
        if (appFile != null) {
          args = ['--json'];
          if (atom.config.get("autocomplete-moose.allowTestObjects")) {
            args.push('--allow-test-objects');
          }
          if (appWSL) {
            moose = cp.spawn('wsl', ['-d', appWSL, appFile].concat(args, {
              stdio: ['pipe', 'pipe', 'ignore']
            }));
          } else {
            moose = cp.spawn(appFile, args, {
              stdio: ['pipe', 'pipe', 'ignore']
            });
          }
          moose.stdout.on('data', function(data) {
            return jsonData += data;
          });
          return moose.on('close', function(code, signal) {
            if (code === 0) {
              return resolve(jsonData);
            } else {
              return reject({
                text: 'Failed to run MOOSE to obtain syntax data',
                code: code,
                signal: signal,
                output: jsonData,
                appFile: appFile
              });
            }
          });
        } else {
          return fs.readFile(appPath, 'utf8', (error, content) => {
            if (error != null) {
              reject({
                text: 'Failed to load offline syntax file',
                name: this.offlineSyntax
              });
            }
            return resolve(content);
          });
        }
      }).then(function(result) {
        var begin, beginMarker, end, endMarker;
        beginMarker = '**START JSON DATA**\n';
        endMarker = '**END JSON DATA**\n';
        begin = result.indexOf(beginMarker);
        end = result.lastIndexOf(endMarker);
        if (begin < 0 || end < begin) {
          throw 'markers not found';
        }
        return JSON.parse(result.slice(begin + beginMarker.length, +(end - 1) + 1 || 9e9));
      }).then(function(result) {
        w.json = result;
        if (cacheFile != null) {
          fs.writeFile(cacheFile, JSON.stringify(w.json), function() {});
        }
        workingNotification.dismiss();
        delete w.promise;
        return w;
      }).catch(function(error) {
        workingNotification.dismiss();
        console.log(error);
        return atom.notifications.addError((error != null ? error.text : void 0) || "Failed to obtain syntax data", {
          dismissable: true
        });
      });
      return w.promise = mooseJSON;
    },
    // fetch JSON syntax data
    loadSyntax: function(app) {
      var appDate, appFile, appName, appPath, cacheDate, cacheDir, cacheFile, loadCache, w;
      ({appPath, appName, appFile, appDate} = app);
      // prepare entry in the syntax warehouse
      w = syntaxWarehouse[appPath] = {};
      // do not cache offlineSyntax
      if (appName) {
        // we cache syntax data here
        cacheDir = path.join(__dirname, '..', 'cache');
        fs.makeTreeSync(cacheDir);
        cacheFile = path.join(cacheDir, `${appName}.json`);
        // see if the cache file exists
        if (fs.existsSync(cacheFile)) {
          cacheDate = fs.statSync(cacheFile).mtime.getTime();
          // if the cacheFile is newer than the app compile date we use the cache
          if (cacheDate > appDate) {
            // return chained promises to load and parse the cached syntax
            loadCache = new Promise(function(resolve, reject) {
              return fs.readFile(cacheFile, 'utf8', function(error, content) {
                if (error != null) {
                  reject();
                }
                return resolve(content);
              });
            }).then(JSON.parse).then(function(result) {
              if (!('blocks' in result)) {
                // validate cache version
                throw 'Invalid cache';
              }
              return result;
            }).then(function(result) {
              delete w.promise;
              return w.json = result;
            }).catch(function() {
              // TODO: rebuild syntax if loading the cache fails
              atom.notifications.addWarning('Failed to load cached syntax (probably a legacy cache file).', {
                dismissable: true
              });
              delete syntaxWarehouse[appPath];
              return fs.unlink(cacheFile, function() {});
            });
            w.promise = loadCache;
            return w.promise;
          }
        }
      }
      return this.rebuildSyntax(app, cacheFile, w);
    }
  };

}).call(this);
